#include <iostream>

/*
 * Сортировка пузырьком (Bubble sort) - это метод сортировки, при котором элементы просматриваются поочередно попарно
 * и меняются местами, если они стоят в неправильном порядке. При каждом проходе самый большой элемент "всплывает" в конец массива.
 * Сложность алгоритма O(n^2).
 */

void sort_bubble(int arr[], int size) {
    for (int i = 0; i < size - 1; ++i) {
        for (int j = 0; j < size - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) { // если текущий элемент больше следующего
                std::swap(arr[j], arr[j + 1]); // меняем их местами
            }
        }
    }
}

/*
 * Можно улучшить эффективность метода пузырька за счет того, что если на какой-то итерации не было ни одной перестановки,
 * то массив уже отсортирован и можно прервать выполнение алгоритма.
 * Для этого добавим переменную, которая будет отслеживать, были ли перестановки на текущей итерации.
 * Если перестановок не было, то прерываем выполнение алгоритма.
 * Таким образом, если массив уже отсортирован, то алгоритм будет работать за O(n), где n - количество элементов в массиве.
 * Перепишем функцию sort_bubble с учетом этого улучшения:
*/

void sort_bubble_improved(int arr[], int size) {
    for (int i = 0; i < size - 1; ++i) { // проходим по массиву
        bool swapped = false; // флаг, который показывает были ли перестановки на текущей итерации
        for (int j = 0; j < size - i - 1; ++j) { // проходим по массиву до i-го элемента
            if (arr[j] > arr[j + 1]) { // если текущий элемент больше следующего
                std::swap(arr[j], arr[j + 1]); // меняем их местами
                swapped = true; // устанавливаем флаг в true
            }
        }
        if (!swapped) { // если перестановок не было
            break; // прерываем выполнение алгоритма
        }
    }
}

/*
 * Шейкер сортировка (Cocktail sort) - это улучшенная версия сортировки пузырьком.
 * Она проходит по списку в обоих направлениях, что позволяет быстрее перемещать элементы к их правильным позициям.
 * При каждом проходе фиксируются левый/правые индексы последнего обмена и проходы повторяются до тех пор,
 * пока левый индекс не станет больше правого.
*/

void sort_shaker(int arr[], int size) {
    int left = 0; // левый индекс
    int right = size - 1; // правый индекс
    while (left <= right) { // пока левый индекс меньше или равен правому
        for (int i = left; i < right; ++i) { // проходим слева направо
            if (arr[i] > arr[i + 1]) { // если текущий элемент больше следующего
                std::swap(arr[i], arr[i + 1]); // меняем их местами
            }
        }
        --right; // уменьшаем правый индекс
        for (int i = right; i > left; --i) { // проходим справа налево
            if (arr[i] < arr[i - 1]) { // если текущий элемент меньше предыдущего
                std::swap(arr[i], arr[i - 1]); // меняем их местами
            }
        }
        ++left;
    }
}

/*
 * Сортировка вставками (методом включений) - это метод сортировки, который проходит по списку и вставляет каждый элемент
 * в правильное место. Начиная со второго элемента каждый элемент записывается в промежуточную переменную, просматриваются
 * предыдущие элементы и ищется место вставки для текущего элемента, чтобы не нарушилась упорядоченность. При этом все элементы,
 * которые больше текущего сдвигаются на одну позицию вправо. И так до тех пор, пока не найдем элемент меньше текущего.
 * На это место и вставляем текущий элемент. Сложность алгоритма O(n^2).
 */

void sort_insertion(int arr[], int size)
{
    for (int i = 1; i < size; ++i) { // начинаем со второго элемента
        int key = arr[i]; // запоминаем текущий элемент
        int j = i - 1; // индекс предыдущего элемента
        while (j >= 0 && arr[j] > key) { // пока не дошли до начала массива и предыдущий элемент больше текущего
            arr[j + 1] = arr[j]; // сдвигаем элемент вправо
            --j; // переходим к следующему элементу
        }
        arr[j + 1] = key; // вставляем текущий элемент на свое место
    }
}

/*
 * Сортировка выбором (Selection sort) - нахожит максимальный элемент массива, меняет его местами с последним
 * элементом массива, повторяет те же действия с n-1 элементами массива, n-2 элементами и т.д, пока не останется один элемент.
 * Сложность алгоритма O(n^2).
 */

void sort_selection(int arr[], int size)
{
    for (int i = size - 1; i > 0; --i) { // i - индекс последнего элемента
        int max_index = 0; // индекс максимального элемента
        for (int j = 0; j < i; ++j) { // j - индекс текущего элемента
            if (arr[j] > arr[max_index]) { // если текущий элемент больше максимального
                max_index = j; // обновляем индекс максимального элемента
            }
        }
        std::swap(arr[i], arr[max_index]); // меняем местами максимальный элемент и последний элемент
    }
}

/*
 * Сортировка Шелла - это алгоритм сортировки, который использует принцип "разделяй и властвуй".
 * Сначала сравниваются и сортируются между собой значения стоящие один от другого на некотором расстоянии step,
 * после этого значение step уменьшается и процесс повторяется, пока все элементы не станут упорядоченными
 * (при step = 1, выполняется последний этап сортировки). Сложность алгоритма обуславливается тем,
 * что элементы быстрее встают на свои места. В среднем O(n log n).
 */

void sort_shell(int arr[], int size)
{
    int step = size; // начальное значение шага равно размеру массива
    do { // выполняем цикл, пока шаг не станет равен 1
        step = step/3 + 1; // уменьшаем шаг
        for (int k = 0; k < step; ++k) { // проходим по всем группам
            for (int i = k + step; i < size; i += step) { // проходим по элементам внутри группы
                int c = arr[i]; // сохраняем текущий элемент
                int j = i - step; // индекс предыдущего элемента
                while (j >= 0 && arr[j] > c) { // пока не дошли до начала массива и предыдущий элемент больше текущего
                    arr[j + step] = arr[j]; // сдвигаем элемент вправо
                    j -= step; // переходим к следующему элементу
                }
                arr[j + step] = c; // вставляем текущий элемент на свое место
            }
        }
    } while (step != 1); // повторяем цикл, пока шаг не станет равен 1
}

// Альтернативный вариант сортировки Шелла

void sort_shell_alternative(int arr[], int size) {
    for (int step = size / 2; step > 0; step /= 2) { // начинаем с большого шага, уменьшаем его каждый раз вдвое
        for (int i = step; i < size; ++i) { // проходим по элементам, начиная с элемента с индексом step
            int temp = arr[i]; // сохраняем текущий элемент
            int j;
            for (j = i; j >= step && arr[j - step] > temp; j -= step) { // сдвигаем элементы, пока не найдем место для текущего элемента
                arr[j] = arr[j - step];
            }
            arr[j] = temp; // вставляем текущий элемент на его место
        }
    }
}